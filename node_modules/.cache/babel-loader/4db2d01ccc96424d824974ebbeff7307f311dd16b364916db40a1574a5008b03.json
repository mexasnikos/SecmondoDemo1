{"ast":null,"code":"// API service for communicating with the backend\nconst API_BASE_URL = process.env.REACT_APP_API_URL || 'http://localhost:5002/api';\nclass ApiService {\n  async makeRequest(endpoint, options = {}) {\n    const url = `${API_BASE_URL}${endpoint}`;\n\n    // Create timeout controller for better browser compatibility\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => controller.abort(), 30000); // 30 second timeout\n\n    const defaultOptions = {\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      signal: controller.signal\n    };\n    const config = {\n      ...defaultOptions,\n      ...options\n    };\n    try {\n      // console.log(`Making API request to: ${url}`, config);\n      const response = await fetch(url, config);\n\n      // Clear timeout on successful response\n      clearTimeout(timeoutId);\n      let data;\n      try {\n        data = await response.json();\n      } catch (jsonError) {\n        console.error('Failed to parse JSON response:', jsonError);\n        throw new Error(`Invalid JSON response from server`);\n      }\n      if (!response.ok) {\n        console.error('API request failed:', {\n          status: response.status,\n          data\n        });\n        console.error('Full error details:', JSON.stringify(data, null, 2));\n        throw new Error(data.message || data.error || `HTTP error! status: ${response.status}`);\n      }\n\n      // console.log('API request successful:', data);\n      return data;\n    } catch (error) {\n      // Clear timeout on error\n      clearTimeout(timeoutId);\n      console.error('API Request Error:', error);\n\n      // Enhanced error handling with more specific messages\n      if (error instanceof TypeError) {\n        if (error.message.includes('fetch') || error.message.includes('NetworkError')) {\n          throw new Error('Unable to connect to the server. Please check if the backend is running.');\n        }\n        if (error.message.includes('Failed to fetch')) {\n          throw new Error('Network error: Please check your internet connection and try again.');\n        }\n      }\n\n      // Handle timeout errors\n      if (error instanceof Error && error.name === 'AbortError') {\n        throw new Error('Request timeout: The server is taking too long to respond.');\n      }\n      throw error;\n    }\n  }\n\n  // Health check with better error handling\n  async healthCheck() {\n    try {\n      return this.makeRequest('/health');\n    } catch (error) {\n      console.error('Health check failed:', error);\n      // Re-throw with more specific message\n      if (error instanceof Error && error.message.includes('connect to the server')) {\n        throw new Error('Backend server is not running. Please start the server on port 5002.');\n      }\n      throw error;\n    }\n  }\n\n  // Test database connection\n  async testDatabase() {\n    return this.makeRequest('/db-test');\n  }\n\n  // Create new quote\n  async createQuote(quoteData) {\n    return this.makeRequest('/quotes', {\n      method: 'POST',\n      body: JSON.stringify(quoteData)\n    });\n  }\n\n  // Get quote by ID\n  async getQuote(quoteId) {\n    return this.makeRequest(`/quotes/${quoteId}`);\n  }\n\n  // Get all quotes (with pagination)\n  async getQuotes(page = 1, limit = 10) {\n    return this.makeRequest(`/quotes?page=${page}&limit=${limit}`);\n  }\n\n  // Submit contact form\n  async submitContact(contactData) {\n    return this.makeRequest('/contact', {\n      method: 'POST',\n      body: JSON.stringify(contactData)\n    });\n  }\n\n  // Process payment - with better error handling and validation\n  async processPayment(paymentData) {\n    try {\n      // Validate payment data before sending\n      if (!paymentData.amount || paymentData.amount <= 0) {\n        throw new Error('Invalid payment amount');\n      }\n      if (!paymentData.cardNumber || paymentData.cardNumber.length < 13) {\n        throw new Error('Invalid card number');\n      }\n      if (!paymentData.cvv || paymentData.cvv.length < 3) {\n        throw new Error('Invalid CVV');\n      }\n\n      // First check if the backend is responding\n      await this.healthCheck();\n\n      // console.log('Payment validation passed, processing...');\n\n      // Then try the payment\n      return this.makeRequest('/payments', {\n        method: 'POST',\n        body: JSON.stringify(paymentData)\n      });\n    } catch (error) {\n      console.error('Payment processing failed:', error);\n\n      // Return a mock successful response if backend is down\n      // This allows testing the frontend flow\n      if (error instanceof Error && error.message.includes('connect to the server')) {\n        // console.warn('Backend not available, returning mock payment response');\n        return {\n          status: 'success',\n          message: 'Payment processed successfully (mock response)',\n          data: {\n            policyNumber: `TI-${Date.now().toString().slice(-8)}`,\n            paymentId: Math.floor(Math.random() * 10000)\n          }\n        };\n      }\n      throw error;\n    }\n  }\n\n  // Get statistics\n  async getStatistics() {\n    return this.makeRequest('/stats');\n  }\n\n  // Get addons by policy type\n  async getAddonsByPolicyType(policyType) {\n    return this.makeRequest(`/addons/${encodeURIComponent(policyType)}`);\n  }\n}\n\n// Create singleton instance\nconst apiService = new ApiService();\n\n// Export individual methods with proper binding\nexport const healthCheck = () => apiService.healthCheck();\nexport const testDatabase = () => apiService.testDatabase();\nexport const createQuote = quoteData => apiService.createQuote(quoteData);\nexport const getQuote = quoteId => apiService.getQuote(quoteId);\nexport const getQuotes = (page, limit) => apiService.getQuotes(page, limit);\nexport const submitContact = contactData => apiService.submitContact(contactData);\nexport const processPayment = paymentData => apiService.processPayment(paymentData);\nexport const getStatistics = () => apiService.getStatistics();\nexport const getAddonsByPolicyType = policyType => apiService.getAddonsByPolicyType(policyType);\nexport default apiService;\n\n// Export types for use in components","map":{"version":3,"names":["API_BASE_URL","process","env","REACT_APP_API_URL","ApiService","makeRequest","endpoint","options","url","controller","AbortController","timeoutId","setTimeout","abort","defaultOptions","headers","signal","config","response","fetch","clearTimeout","data","json","jsonError","console","error","Error","ok","status","JSON","stringify","message","TypeError","includes","name","healthCheck","testDatabase","createQuote","quoteData","method","body","getQuote","quoteId","getQuotes","page","limit","submitContact","contactData","processPayment","paymentData","amount","cardNumber","length","cvv","policyNumber","Date","now","toString","slice","paymentId","Math","floor","random","getStatistics","getAddonsByPolicyType","policyType","encodeURIComponent","apiService"],"sources":["C:/Users/laptop-123/TravelInsurance_Demo_2/src/services/apiService.ts"],"sourcesContent":["// API service for communicating with the backend\nconst API_BASE_URL = process.env.REACT_APP_API_URL || 'http://localhost:5002/api';\n\ninterface ApiResponse<T> {\n  status: 'success' | 'error';\n  message: string;\n  data?: T;\n  error?: string;\n}\n\ninterface QuoteData {\n  destination: string;\n  startDate: string;\n  endDate: string;\n  tripType: string;\n  numberOfTravelers: number;\n  travelers: TravelerInfo[];\n  selectedQuote: any;\n  additionalPolicies: any[];\n  totalAmount: number;\n}\n\ninterface TravelerInfo {\n  firstName: string;\n  lastName: string;\n  age: string;\n  email: string;\n  phone: string;\n  vaxId: string;\n  nationality: string;\n}\n\ninterface ContactData {\n  name: string;\n  email: string;\n  subject: string;\n  message: string;\n}\n\ninterface PaymentData {\n  quoteId: number;\n  paymentMethod: string;\n  cardNumber: string;\n  expiryDate: string;\n  cvv: string;\n  billingAddress: {\n    street: string;\n    city: string;\n    postalCode: string;\n    country: string;\n  };\n  amount: number;\n}\n\nclass ApiService {\n  private async makeRequest<T>(\n    endpoint: string, \n    options: RequestInit = {}\n  ): Promise<ApiResponse<T>> {\n    const url = `${API_BASE_URL}${endpoint}`;\n    \n    // Create timeout controller for better browser compatibility\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => controller.abort(), 30000); // 30 second timeout\n    \n    const defaultOptions: RequestInit = {\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      signal: controller.signal,\n    };\n\n    const config = { ...defaultOptions, ...options };\n\n    try {\n      // console.log(`Making API request to: ${url}`, config);\n      const response = await fetch(url, config);\n      \n      // Clear timeout on successful response\n      clearTimeout(timeoutId);\n      \n      let data;\n      try {\n        data = await response.json();\n      } catch (jsonError) {\n        console.error('Failed to parse JSON response:', jsonError);\n        throw new Error(`Invalid JSON response from server`);\n      }\n\n      if (!response.ok) {\n        console.error('API request failed:', { status: response.status, data });\n        console.error('Full error details:', JSON.stringify(data, null, 2));\n        throw new Error(data.message || data.error || `HTTP error! status: ${response.status}`);\n      }\n\n      // console.log('API request successful:', data);\n      return data;\n    } catch (error) {\n      // Clear timeout on error\n      clearTimeout(timeoutId);\n      console.error('API Request Error:', error);\n      \n      // Enhanced error handling with more specific messages\n      if (error instanceof TypeError) {\n        if (error.message.includes('fetch') || error.message.includes('NetworkError')) {\n          throw new Error('Unable to connect to the server. Please check if the backend is running.');\n        }\n        if (error.message.includes('Failed to fetch')) {\n          throw new Error('Network error: Please check your internet connection and try again.');\n        }\n      }\n      \n      // Handle timeout errors\n      if (error instanceof Error && error.name === 'AbortError') {\n        throw new Error('Request timeout: The server is taking too long to respond.');\n      }\n      \n      throw error;\n    }\n  }\n\n  // Health check with better error handling\n  async healthCheck(): Promise<ApiResponse<any>> {\n    try {\n      return this.makeRequest('/health');\n    } catch (error) {\n      console.error('Health check failed:', error);\n      // Re-throw with more specific message\n      if (error instanceof Error && error.message.includes('connect to the server')) {\n        throw new Error('Backend server is not running. Please start the server on port 5002.');\n      }\n      throw error;\n    }\n  }\n\n  // Test database connection\n  async testDatabase(): Promise<ApiResponse<any>> {\n    return this.makeRequest('/db-test');\n  }\n\n  // Create new quote\n  async createQuote(quoteData: QuoteData): Promise<ApiResponse<{ quoteId: number }>> {\n    return this.makeRequest('/quotes', {\n      method: 'POST',\n      body: JSON.stringify(quoteData),\n    });\n  }\n\n  // Get quote by ID\n  async getQuote(quoteId: number): Promise<ApiResponse<any>> {\n    return this.makeRequest(`/quotes/${quoteId}`);\n  }\n\n  // Get all quotes (with pagination)\n  async getQuotes(page: number = 1, limit: number = 10): Promise<ApiResponse<any>> {\n    return this.makeRequest(`/quotes?page=${page}&limit=${limit}`);\n  }\n\n  // Submit contact form\n  async submitContact(contactData: ContactData): Promise<ApiResponse<{ messageId: number }>> {\n    return this.makeRequest('/contact', {\n      method: 'POST',\n      body: JSON.stringify(contactData),\n    });\n  }\n\n  // Process payment - with better error handling and validation\n  async processPayment(paymentData: PaymentData): Promise<ApiResponse<{ policyNumber: string; paymentId: number }>> {\n    try {\n      // Validate payment data before sending\n      if (!paymentData.amount || paymentData.amount <= 0) {\n        throw new Error('Invalid payment amount');\n      }\n      \n      if (!paymentData.cardNumber || paymentData.cardNumber.length < 13) {\n        throw new Error('Invalid card number');\n      }\n      \n      if (!paymentData.cvv || paymentData.cvv.length < 3) {\n        throw new Error('Invalid CVV');\n      }\n      \n      // First check if the backend is responding\n      await this.healthCheck();\n      \n      // console.log('Payment validation passed, processing...');\n      \n      // Then try the payment\n      return this.makeRequest('/payments', {\n        method: 'POST',\n        body: JSON.stringify(paymentData),\n      });\n    } catch (error) {\n      console.error('Payment processing failed:', error);\n      \n      // Return a mock successful response if backend is down\n      // This allows testing the frontend flow\n      if (error instanceof Error && error.message.includes('connect to the server')) {\n        // console.warn('Backend not available, returning mock payment response');\n        return {\n          status: 'success',\n          message: 'Payment processed successfully (mock response)',\n          data: {\n            policyNumber: `TI-${Date.now().toString().slice(-8)}`,\n            paymentId: Math.floor(Math.random() * 10000)\n          }\n        };\n      }\n      \n      throw error;\n    }\n  }\n\n  // Get statistics\n  async getStatistics(): Promise<ApiResponse<any>> {\n    return this.makeRequest('/stats');\n  }\n\n  // Get addons by policy type\n  async getAddonsByPolicyType(policyType: string): Promise<ApiResponse<any>> {\n    return this.makeRequest(`/addons/${encodeURIComponent(policyType)}`);\n  }\n}\n\n// Create singleton instance\nconst apiService = new ApiService();\n\n// Export individual methods with proper binding\nexport const healthCheck = () => apiService.healthCheck();\nexport const testDatabase = () => apiService.testDatabase();\nexport const createQuote = (quoteData: QuoteData) => apiService.createQuote(quoteData);\nexport const getQuote = (quoteId: number) => apiService.getQuote(quoteId);\nexport const getQuotes = (page?: number, limit?: number) => apiService.getQuotes(page, limit);\nexport const submitContact = (contactData: ContactData) => apiService.submitContact(contactData);\nexport const processPayment = (paymentData: PaymentData) => apiService.processPayment(paymentData);\nexport const getStatistics = () => apiService.getStatistics();\nexport const getAddonsByPolicyType = (policyType: string) => apiService.getAddonsByPolicyType(policyType);\n\nexport default apiService;\n\n// Export types for use in components\nexport type {\n  ApiResponse,\n  QuoteData,\n  TravelerInfo,\n  ContactData,\n  PaymentData,\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}